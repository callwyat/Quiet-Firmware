/*
 * File:   Setup.c
 * Author: Wyatt Callister
 *
 * Created on May 21, 2018, 7:58 PM
 */

#include <xc.h>
#include "Setup.h"
#include "QyA_Code.h"
#include "Servo.h"
#include "Subroutines.h"
#include "Settings.h"

//Stores the current output mode
extern OutModeDefinition OutputMode;
//Stores the value of the Servo Outputs
extern q_int Servo_Buffers[10];
//Stores the settings
extern QyA_Settings Settings;

//Used to reset all channels
void ServosSetup(void)
{
    PR2 = 250;          //Setup Timer 2 to have 1mS period
    T2CON = 0x07;
    
    PR4 = 0xFF;         //Setup Timer 4 to run as fast as possible
    T4CON = 0x04;
    
    CCPTMRS1 = 0x00;    //Set CCP4 - 7 to use TMR2
    CCPTMRS0bits.C3TSEL = 0;    //Set CCP3 -> TMR2
    
    //Enable all the always on PWMs
    PWM1L = 0x0C;
    PWM2L = 0x0C;
    PWM3L = 0x0C;
    
//Test Code
//    OutputMode.PWMS = 0x0F;     //Uncomment to test Digital PWMs
//    
//    OutputMode.AServo = 0x03;   //Uncomment to test Analog Servo mode
//    OutputMode.DServo = 0xFF;   //Uncomment to test Digital Servo mode
//End Test Code
    
    //Setup the individual channels
    for(unsigned char count = 0; count <= 9; count++)
    {
        ServoSetup(count);
    }
    
    IPR1bits.TMR2IP = 1;  //Set Timer 2 interrupt to High Priority
    //To reduce number of calls the High Interrupt vector, this interrupt is not
    //enabled. Instead it will be checked when an analog conversion is completed
    //which takes place every 250uS.
    //PIE1bits.TMR2IE = 1;  //Enable Timer 2 interrupts
}

//Used to change the state of a channel. (Most values are pulled from settings)
unsigned ServoSetup(unsigned char Channel)
{
    if(Channel > 10)    //Test if the channel number is not valid
    {   //Not a valid channel
        return false;
    }
    
    //Establish a pointer to the CCPxCON and CCPRxL
    unsigned char *PWMPnt;

    //Set the Servo_Buffer to the default value
    Servo_Buffers[Channel].Lower |= 0x0C;                   
    Servo_Buffers[Channel].Higher = Settings.Servo[Channel];
            
    //Test if changing a Analog/PWM/Servo
    if(Channel < 2)    //Lower PWM numbers
    {   //Test if running is servo mode
        if(GetBit(OutputMode.AServo, Channel))
        {   //Servo Mode
            //Use Servo Timer
            if(Channel == 0) CCPTMRS0bits.C1TSEL = 0; else CCPTMRS0bits.C2TSEL = 0;  //TMR2
        }
        else
        {   //PWM Mode
            //Use the High Speed Timer
            if(Channel == 0) CCPTMRS0bits.C1TSEL = 1; else CCPTMRS0bits.C2TSEL = 1;   //TMR4
            
            //Restore the Default Value to the PWM
            PWMPnt = &PWM1H - (unsigned char*)(Channel * (&PWM1H - &PWM2H));
            *PWMPnt = Settings.Servo[Channel];
            
            //Turn the channel on
            PWMPnt = PWMPnt + (&PWM1H - &PWM1L);
            *PWMPnt = 0x0C;     //Set CCPxCON
        }
        return true;
    }
    
    //Test if Changing a Servo
    if(Channel < 6)
    {   //Test if the output should be used and map the PWM if needed
        Channel = Channel - 2;
        
        unsigned char *MapPnt = (unsigned char*)(&RPOR3 + Channel);
        if(GetBit(OutputMode.DServo, Channel)) *MapPnt = 22 + Channel; else *MapPnt = 0;
    }
    //Other wise it is a PWM/Servo/Digital
    else
    {   
        Channel = Channel - 6;
            
        //Setup the pointer to the CCPxCON register
        PWMPnt = &PWM7L - (unsigned char*)(Channel * (&PWM7L - &PWM8L));
            
        if(GetBit(OutputMode.PWMS, Channel)) 
        {
            *PWMPnt = 0x0C; //Set CCPxCOn (Enabled)
            
            //Test if not in Servo Mode
            if(!GetBit(OutputMode.DServo >> 4, Channel))
            {   //PWM Mode
                //Restore the PWM Value from the setting
                PWMPnt = PWMPnt + (&PWM7H - &PWM7L);
                *PWMPnt = Settings.Servo[Channel + 6];
            }
        } 
        else 
        {
            *PWMPnt = 0;  //Set CCPxCON (Not enabled)
        }
    }
        
    return true;
}


ServoState servoState = Default;

//This routine should be called every 1mS when an interrupt is generated by
//a PWM overflow.

//PWM3 doesn't need checked before updating because the outputs outputs will
//be assigned if they have been enabled by the user. Otherwise the signal will
//be routed nowhere

//This method for updating the servos takes advantage of a switch. This allows
//removes the File Pointers (FSRs) from the function allowing for faster
//context switching. However, it is heavier on Program memory.
void UpdateServo(void)
{   
    //Increment to the next state
    servoState++;
    
    switch(servoState)
    {
        case _137High:  
            T2CON = 0x07;
                        
            if(OutputMode.Servo1) { PWM1H = 0xFF; PWM1L |=  0x30; }
            if(OutputMode.Servo7) { PWM7H = 0xFF; PWM7L |=  0x30; }
            
            //Move to PWM3 Location
            PSTR3CON = 0x11;
            PWM3H = 0xFF; 
            PWM3L |=  0x30;
            break;
        case _137Transition:
            if(OutputMode.Servo1) { PWM1H = Servo_Buffers[0].Higher; PWM1L =  Servo_Buffers[0].Lower; }
            if(OutputMode.Servo7) { PWM7H = Servo_Buffers[6].Higher; PWM7L =  Servo_Buffers[6].Lower; }
            
            PWM3H = Servo_Buffers[2].Higher; 
            PWM3L =  Servo_Buffers[2].Lower;
            break;
        case _248High:
            if(OutputMode.Servo1) { PWM1H = 0x00; PWM1L &=  0xCF; }
            if(OutputMode.Servo7) { PWM7H = 0x00; PWM7L &=  0xCF; }
            
            if(OutputMode.Servo2) { PWM2H = 0xFF; PWM2L |=  0x30; }
            if(OutputMode.Servo8) { PWM8H = 0xFF; PWM8L |=  0x30; }
            
            //Move to PWM4 Location
            PSTR3CON = 0x12;
            PWM3H = 0xFF; 
            PWM3L |=  0x30;
            break;
        case _248Transition:
            if(OutputMode.Servo2) { PWM2H = Servo_Buffers[1].Higher; PWM2L =  Servo_Buffers[1].Lower; }
            if(OutputMode.Servo8) { PWM8H = Servo_Buffers[7].Higher; PWM8L =  Servo_Buffers[7].Lower; }
            
            PWM3H = Servo_Buffers[3].Higher; 
            PWM3L =  Servo_Buffers[3].Lower;
            break;
        case _59High:
            if(OutputMode.Servo2) { PWM2H = 0x00; PWM2L &=  0xCF; }
            if(OutputMode.Servo8) { PWM8H = 0x00; PWM8L &=  0xCF; }
            
            if(OutputMode.Servo9) { PWM9H = 0xFF; PWM9L |=  0x30; }
            
            //Move to PWM5 Location
            PSTR3CON = 0x14;
            PWM3H = 0xFF; 
            PWM3L |=  0x30;
            break;
        case _59Transistion:
            if(OutputMode.Servo9) { PWM9H = Servo_Buffers[8].Higher; PWM9L =  Servo_Buffers[8].Lower; }
            
            PWM3H = Servo_Buffers[4].Higher; 
            PWM3L =  Servo_Buffers[4].Lower;
            break;
        case _60High:
            if(OutputMode.Servo9) { PWM9H = 0x00; PWM9L &=  0xCF; }
            
            if(OutputMode.Servo10) { PWM10H = 0xFF; PWM10L |=  0x30; }
            
            //Move to PWM6 Location
            PSTR3CON = 0x18;
            PWM3H = 0xFF; 
            PWM3L |=  0x30;
            break;
        case _60Transistion:
            if(OutputMode.Servo10) { PWM10H = Servo_Buffers[9].Higher; PWM10L =  Servo_Buffers[9].Lower; }
            
            PWM3H = Servo_Buffers[5].Higher; 
            PWM3L =  Servo_Buffers[5].Lower;
            
            break;
        case Idle:
            if(OutputMode.Servo10) { PWM10H = 0x00; PWM10L &=  0xCF; }
            
            //Don't drive an output
            PSTR3CON = 0x10;
            PWM3H = 0x00; 
            PWM3L &= 0xCF;
            
            //Don't interrupt again for 11mS
            T2CON = 0x5F;  
                        
            //Reset the Servo State
            servoState = Default;
            break;
            
        default:
            //Reset the Servo State
            servoState = Default;
            break;
    }
}